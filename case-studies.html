<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Real-world case studies applying prompt engineering techniques to complex software projects.">
    <title>Case Studies | Prompt Engineering Taxonomy</title>
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        .case-study-hero {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            padding: 4rem 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 3rem;
            color: white;
            text-align: center;
        }

        .case-study-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
        }

        .case-study-card {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 2rem;
            padding: 2rem;
            align-items: center;
        }

        @media (max-width: 768px) {
            .case-study-card {
                grid-template-columns: 1fr;
            }
        }

        .case-study-image {
            background-color: var(--bg-body);
            height: 250px;
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            color: var(--primary);
            border: 1px solid var(--border-color);
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .tech-badge {
            background-color: var(--bg-body);
            border: 1px solid var(--border-color);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .technique-highlight {
            background-color: rgba(79, 70, 229, 0.1);
            color: var(--primary);
            border: 1px solid var(--primary-light);
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-block;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <header></header>

    <main>
        <section class="case-study-hero reveal fade-in">
            <h1>Applied Prompt Engineering</h1>
            <p>From theory to practice: How we use advanced techniques to build intelligent software systems.</p>
        </section>

        <div class="case-study-grid">
            <!-- Case Study 1 -->
            <article class="feature-card case-study-card reveal slide-up">
                <div class="case-study-image">
                    <i class="fas fa-dungeon"></i>
                </div>
                <div class="case-study-content">
                    <span class="technique-highlight">Context Engineering</span>
                    <span class="technique-highlight">MCP Integration</span>
                    <h2>Quest Keeper AI: Modular Game State</h2>
                    <p>
                        <strong>Challenge:</strong> Managing complex, persistent D&D game states (inventory, combat, spells) across multiple sessions without overwhelming the LLM's context window.
                    </p>
                    <p>
                        <strong>Solution:</strong> Implemented the **Model Context Protocol (MCP)** to separate concerns. A Rust-based backend handles state logic, while the LLM acts as an orchestrator, calling specific tools (`roll_dice`, `get_inventory`) only when needed.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-badge">Rust</span>
                        <span class="tech-badge">MCP</span>
                        <span class="tech-badge">React</span>
                        <span class="tech-badge">Context Federation</span>
                    </div>
                </div>
            </article>

            <!-- Case Study 2 -->
            <article class="feature-card case-study-card reveal slide-up delay-100">
                <div class="case-study-image">
                    <i class="fas fa-shield-dog"></i>
                </div>
                <div class="case-study-content">
                    <span class="technique-highlight">Self-Reflection</span>
                    <span class="technique-highlight">Automated Debugging</span>
                    <h2>Watchdog System: Self-Healing AI</h2>
                    <p>
                        <strong>Challenge:</strong> AI agents can fail silently or hallucinate parameters when calling complex tools.
                    </p>
                    <p>
                        <strong>Solution:</strong> Created a **Watchdog Service** with a circular log buffer. When an error occurs, the system captures the exact context and tool input, feeding it back to a secondary "Debugger Agent" loop to analyze and fix the issue automatically.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-badge">Zod Validation</span>
                        <span class="tech-badge">Circular Buffer</span>
                        <span class="tech-badge">Error Recovery</span>
                    </div>
                </div>
            </article>

            <!-- Case Study 3 -->
            <article class="feature-card case-study-card reveal slide-up delay-200">
                <div class="case-study-image">
                    <i class="fas fa-window-restore"></i>
                </div>
                <div class="case-study-content">
                    <span class="technique-highlight">System 2 Thinking</span>
                    <span class="technique-highlight">Reactive Agents</span>
                    <h2>Event-Driven Window Management</h2>
                    <p>
                        <strong>Challenge:</strong> Traditional polling for window states creates lag and consumes resources, leading to flaky desktop automation.
                    </p>
                    <p>
                        <strong>Solution:</strong> Shifted to an **Event-Driven Architecture** using UI Automation hooks. The agent waits for specific system events (e.g., "Save As" dialog open) before proceeding, mimicking human "System 2" deliberate attention.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-badge">C# / .NET</span>
                        <span class="tech-badge">Win32 API</span>
                        <span class="tech-badge">Reactive Patterns</span>
                    </div>
                </div>
            </article>
        </div>

        <section class="quick-start-box reveal">
            <h2>Start Building Your Own</h2>
            <p>Use these techniques in your next project.</p>
            <div class="quick-start-buttons">
                <a href="reports/taxonomy-overview.html" class="quick-start-button">Explore Taxonomy</a>
                <a href="workflow-patterns.html" class="quick-start-button">Workflow Patterns</a>
            </div>
        </section>

    </main>

    <footer></footer>

    <script src="assets/js/header-footer.js"></script>
    <script src="assets/js/main.js"></script>
</body>
</html>
